#!/bin/bash
# Monitor hyperparameter sweep jobs
# Generated by ML Dev Env deployment wizard

APP_NAME="{app_name}"
NAMESPACE="{namespace}"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
GRAY='\033[0;90m'
NC='\033[0m' # No Color

# Parse command line arguments
FOLLOW_LOGS=false
JOB_FILTER=""

while [[ $# -gt 0 ]]; do
    case $1 in
        -f|--follow)
            FOLLOW_LOGS=true
            shift
            ;;
        -j|--job)
            JOB_FILTER="$2"
            shift 2
            ;;
        -h|--help)
            echo "Usage: $0 [OPTIONS]"
            echo ""
            echo "Monitor hyperparameter sweep jobs"
            echo ""
            echo "Options:"
            echo "  -f, --follow          Follow logs from all running jobs"
            echo "  -j, --job JOB_ID      Show logs for specific job ID"
            echo "  -h, --help            Show this help message"
            echo ""
            echo "Examples:"
            echo "  $0                    Show status table"
            echo "  $0 --follow           Watch logs from all jobs"
            echo "  $0 --job lr0.001-bs32 Show logs for specific job"
            exit 0
            ;;
        *)
            echo "Unknown option: $1"
            echo "Use --help for usage information"
            exit 1
            ;;
    esac
done

# Function to display status table
show_status_table() {
    echo -e "${BLUE}‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ${NC}"
    echo -e "${BLUE}  Hyperparameter Sweep Status - $APP_NAME${NC}"
    echo -e "${BLUE}‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ${NC}"
    echo

    # Get all sweep jobs
    JOBS_JSON=$(oc get jobs -n $NAMESPACE -l app=$APP_NAME,sweep=true -o json 2>/dev/null)

    if [ $? -ne 0 ]; then
        echo -e "${RED}‚úó Error: Could not fetch jobs${NC}"
        echo "  Make sure you're logged in: oc login"
        exit 1
    fi

    # Check if any jobs exist
    JOB_COUNT=$(echo "$JOBS_JSON" | python3 -c "import sys, json; print(len(json.load(sys.stdin).get('items', [])))")

    if [ "$JOB_COUNT" -eq 0 ]; then
        echo -e "${YELLOW}No sweep jobs found${NC}"
        echo ""
        echo "Submit jobs with: ./scripts/submit-sweep.sh"
        exit 0
    fi

    # Parse and display job information
    echo "$JOBS_JSON" | python3 <<'PYTHON_EOF'
import json
import sys
from datetime import datetime, timezone

jobs_data = json.load(sys.stdin)
jobs = jobs_data.get("items", [])

# Sort by creation time
jobs.sort(key=lambda j: j["metadata"]["creationTimestamp"])

# Status symbols
status_symbols = {
    "Running": "üîÑ",
    "Succeeded": "‚úÖ",
    "Failed": "‚ùå",
    "Pending": "‚è≥"
}

# Print table header
print(f"{'Status':<10} {'Job ID':<30} {'Duration':<12} {'Started':<20}")
print("‚îÄ" * 75)

for job in jobs:
    metadata = job["metadata"]
    status_info = job.get("status", {})

    # Extract job ID (remove app name prefix)
    full_name = metadata["name"]
    job_id = full_name.replace("${APP_NAME}-job-", "")

    # Determine status
    if status_info.get("succeeded", 0) > 0:
        status = "Succeeded"
        color = "\033[0;32m"  # Green
    elif status_info.get("failed", 0) > 0:
        status = "Failed"
        color = "\033[0;31m"  # Red
    elif status_info.get("active", 0) > 0:
        status = "Running"
        color = "\033[1;33m"  # Yellow
    else:
        status = "Pending"
        color = "\033[0;36m"  # Cyan

    nc = "\033[0m"
    symbol = status_symbols.get(status, "  ")

    # Calculate duration
    start_time = status_info.get("startTime")
    completion_time = status_info.get("completionTime")

    if completion_time:
        start = datetime.fromisoformat(start_time.replace("Z", "+00:00"))
        end = datetime.fromisoformat(completion_time.replace("Z", "+00:00"))
        duration = end - start
        duration_str = str(duration).split(".")[0]  # Remove microseconds
    elif start_time:
        start = datetime.fromisoformat(start_time.replace("Z", "+00:00"))
        now = datetime.now(timezone.utc)
        duration = now - start
        duration_str = str(duration).split(".")[0]  # Remove microseconds
    else:
        duration_str = "Not started"

    # Format start time
    if start_time:
        start = datetime.fromisoformat(start_time.replace("Z", "+00:00"))
        started_str = start.strftime("%Y-%m-%d %H:%M")
    else:
        started_str = "Pending"

    # Print row
    print(f"{color}{symbol} {status:<8}{nc} {job_id:<30} {duration_str:<12} {started_str:<20}")

print("‚îÄ" * 75)

# Summary statistics
total = len(jobs)
succeeded = len([j for j in jobs if j.get("status", {}).get("succeeded", 0) > 0])
failed = len([j for j in jobs if j.get("status", {}).get("failed", 0) > 0])
running = len([j for j in jobs if j.get("status", {}).get("active", 0) > 0])
pending = total - succeeded - failed - running

print(f"\nüìä Summary: {total} total | ‚úÖ {succeeded} succeeded | ‚ùå {failed} failed | üîÑ {running} running | ‚è≥ {pending} pending")
PYTHON_EOF

    echo
    echo -e "${GRAY}Refresh: $0${NC}"
    echo -e "${GRAY}Follow logs: $0 --follow${NC}"
    echo -e "${GRAY}Job logs: $0 --job <job-id>${NC}"
    echo
}

# Function to follow logs from a specific job
follow_job_logs() {
    local job_id=$1
    local job_name="${APP_NAME}-job-${job_id}"

    echo -e "${BLUE}üìã Following logs for: $job_id${NC}"
    echo

    # Get pods for this job
    POD_NAME=$(oc get pods -n $NAMESPACE -l job-name=$job_name -o jsonpath='{.items[0].metadata.name}' 2>/dev/null)

    if [ -z "$POD_NAME" ]; then
        echo -e "${YELLOW}‚è≥ Waiting for pod to start...${NC}"

        # Wait for pod to be created
        for i in {1..30}; do
            sleep 2
            POD_NAME=$(oc get pods -n $NAMESPACE -l job-name=$job_name -o jsonpath='{.items[0].metadata.name}' 2>/dev/null)
            if [ -n "$POD_NAME" ]; then
                break
            fi
        done

        if [ -z "$POD_NAME" ]; then
            echo -e "${RED}‚úó Pod not found for job: $job_id${NC}"
            exit 1
        fi
    fi

    # Follow logs
    oc logs -n $NAMESPACE -f $POD_NAME 2>/dev/null || \
        oc logs -n $NAMESPACE $POD_NAME 2>/dev/null || \
        echo -e "${YELLOW}Pod not ready yet${NC}"
}

# Function to follow all running jobs
follow_all_logs() {
    echo -e "${BLUE}üìã Following logs from all running jobs${NC}"
    echo

    while true; do
        # Get all running jobs
        RUNNING_JOBS=$(oc get jobs -n $NAMESPACE -l app=$APP_NAME,sweep=true -o json 2>/dev/null | \
                       python3 -c "import sys, json; jobs = json.load(sys.stdin).get('items', []); print('\n'.join([j['metadata']['name'].replace('${APP_NAME}-job-', '') for j in jobs if j.get('status', {}).get('active', 0) > 0]))")

        if [ -z "$RUNNING_JOBS" ]; then
            echo -e "${YELLOW}No running jobs. Waiting...${NC}"
            sleep 5
            continue
        fi

        # Show logs from first running job
        JOB_ID=$(echo "$RUNNING_JOBS" | head -n 1)
        echo -e "${CYAN}‚îÅ‚îÅ‚îÅ Logs from: $JOB_ID ‚îÅ‚îÅ‚îÅ${NC}"

        follow_job_logs "$JOB_ID" &
        PID=$!

        # Wait a bit then move to next job
        sleep 10
        kill $PID 2>/dev/null || true

        echo
    done  # end while true
}  # end follow_all_logs

# Main logic
if [ "$FOLLOW_LOGS" = true ]; then
    if [ -n "$JOB_FILTER" ]; then
        follow_job_logs "$JOB_FILTER"
    else
        follow_all_logs
    fi
elif [ -n "$JOB_FILTER" ]; then
    follow_job_logs "$JOB_FILTER"
else
    # Show status table
    show_status_table

    # Option to watch continuously
    if command -v watch &> /dev/null; then
        echo -e "${GRAY}üí° Tip: Use 'watch -n 5 $0' for continuous monitoring${NC}"
    fi
fi
