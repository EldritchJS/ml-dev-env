apiVersion: build.openshift.io/v1
kind: BuildConfig
metadata:
  name: h-kim
  namespace: nccl-test
  labels:
    app: h-kim
    pytorch-version: "2.9"
spec:
  output:
    to:
      kind: ImageStreamTag
      name: h-kim:latest
  source:
    type: Dockerfile
    dockerfile: |
      # H-Kim Image - Minimal PyTorch Environment
      # Based on NVIDIA PyTorch 26.01 (latest stable) with focused package set

      FROM nvcr.io/nvidia/pytorch:26.01-py3 AS base

      # Set environment variables
      ENV PYTHONUNBUFFERED=1 \
          DEBIAN_FRONTEND=noninteractive

      # Install system dependencies
      RUN apt-get update && apt-get install -y \
          git \
          wget \
          vim \
          curl \
          && rm -rf /var/lib/apt/lists/*

      # Install RDMA/InfiniBand tools for multi-node training
      RUN apt-get update && apt-get install -y \
          libibverbs-dev \
          librdmacm-dev \
          rdma-core \
          infiniband-diags \
          pciutils \
          numactl \
          && rm -rf /var/lib/apt/lists/*

      # Upgrade pip and install base build tools
      RUN pip install --no-cache-dir --upgrade pip setuptools wheel

      # Install comprehensive NCCL auto-detection script
      # This script detects all NCCL configuration automatically at runtime
      # See: scripts/autodetect-nccl.sh for the source
      RUN cat > /usr/local/bin/autodetect-nccl.sh <<'AUTODETECT_EOF'
      #!/usr/bin/env bash
      set -euo pipefail

      # Comprehensive NCCL and Environment Auto-Detection
      OUTPUT_FILE="${OUTPUT_FILE:-/shared/nccl-env.sh}"
      VERBOSE="${VERBOSE:-0}"

      log() { echo "[AUTODETECT] $*" >&2; }
      debug() { [[ "$VERBOSE" == "1" ]] && echo "[DEBUG] $*" >&2 || true; }

      detect_gpu_count() {
          command -v nvidia-smi &>/dev/null && nvidia-smi --query-gpu=name --format=csv,noheader 2>/dev/null | wc -l || echo "0"
      }

      detect_nvlink() {
          if command -v nvidia-smi &>/dev/null && nvidia-smi topo -m 2>/dev/null | grep -q "NV"; then
              echo "NVL"
          else
              echo "PIX"
          fi
      }

      detect_gpudirect() {
          if lsmod 2>/dev/null | grep -q "nv_peer_mem" || [[ -d /sys/class/infiniband ]] && command -v nvidia-smi &>/dev/null; then
              echo "5"
          else
              echo "0"
          fi
      }

      detect_gid_index() {
          local ib_dev
          ib_dev=$(command -v ibv_devinfo &>/dev/null && ibv_devinfo -l 2>/dev/null | head -1 || echo "")
          if [[ -n "$ib_dev" ]]; then
              for port in 1 2; do
                  for gid_idx in 0 1 2 3; do
                      if ibv_devinfo -d "$ib_dev" 2>/dev/null | grep -A 20 "port ${port}:" | grep "GID\[${gid_idx}\]" | grep -q "RoCE v2"; then
                          echo "$gid_idx"
                          return 0
                      fi
                  done
              done
          fi
          echo "3"
      }

      detect_omp_threads() {
          local cpu_count=$(nproc 2>/dev/null || echo "32")
          local gpu_count=$(detect_gpu_count)
          if [[ "$gpu_count" -gt 0 ]]; then
              local threads_per_gpu=$((cpu_count / gpu_count))
              [[ "$threads_per_gpu" -lt 4 ]] && echo "4" || [[ "$threads_per_gpu" -gt 16 ]] && echo "16" || echo "$threads_per_gpu"
          else
              echo "8"
          fi
      }

      detect_ib_devices() {
          command -v ibv_devinfo &>/dev/null && ibv_devinfo -l 2>/dev/null | grep -v "^$" | grep -v "HCAs found" | sed 's/^[ \t]*//;s/[ \t]*$//' | tr '\n' ',' | sed 's/,$//' || echo ""
      }

      detect_rdma_interfaces() {
          local ifaces=$(ip -o link show 2>/dev/null | awk -F': ' '{print $2}' | grep -E '^net[0-9]+$' | tr '\n' ',' | sed 's/,$//')
          [[ -n "$ifaces" ]] && echo "$ifaces" && return 0
          ifaces=$(ip -o link show 2>/dev/null | awk -F': ' '{print $2}' | grep -E '^ib[0-9]+$' | tr '\n' ',' | sed 's/,$//')
          [[ -n "$ifaces" ]] && echo "$ifaces" || echo "eth0"
      }

      detect_transport() {
          [[ -d /sys/class/infiniband ]] && [[ -n "$(detect_ib_devices)" ]] && echo "rdma" || echo "tcp"
      }

      log "Starting comprehensive NCCL auto-detection..."
      GPU_COUNT=$(detect_gpu_count)
      IB_DEVICES=$(detect_ib_devices)
      RDMA_IFACES=$(detect_rdma_interfaces)
      NVLINK_LEVEL=$(detect_nvlink)
      GPUDIRECT_LEVEL=$(detect_gpudirect)
      GID_INDEX=$(detect_gid_index)
      OMP_THREADS=$(detect_omp_threads)
      TRANSPORT=$(detect_transport)

      log "Detection results:"
      log "  GPUs: $GPU_COUNT"
      log "  IB devices: ${IB_DEVICES:-none}"
      log "  RDMA interfaces: $RDMA_IFACES"
      log "  NVLink: $NVLINK_LEVEL"
      log "  GPUDirect: level $GPUDIRECT_LEVEL"
      log "  GID index: $GID_INDEX"
      log "  OMP threads: $OMP_THREADS"
      log "  Transport: $TRANSPORT"

      cat > "$OUTPUT_FILE" <<EOF
      # Auto-detected NCCL Configuration
      # Generated by autodetect-nccl.sh - $(date)

      # Hardware Detection
      export DETECTED_GPU_COUNT="$GPU_COUNT"
      export DETECTED_TRANSPORT="$TRANSPORT"

      # NCCL Network Configuration
      EOF

      if [[ "$TRANSPORT" == "rdma" ]] && [[ -n "$IB_DEVICES" ]]; then
          cat >> "$OUTPUT_FILE" <<'INNER_EOF'
      # RDMA/InfiniBand configuration (supports user overrides)
      export NCCL_IB_DISABLE="${NCCL_IB_DISABLE:-0}"
      INNER_EOF
          cat >> "$OUTPUT_FILE" <<EOF
      export NCCL_IB_HCA="\${NCCL_IB_HCA:-${IB_DEVICES}}"
      export NCCL_SOCKET_IFNAME="\${NCCL_SOCKET_IFNAME:-${RDMA_IFACES}}"
      export NCCL_IB_GID_INDEX="\${NCCL_IB_GID_INDEX:-${GID_INDEX}}"
      export NCCL_NET_GDR_LEVEL="\${NCCL_NET_GDR_LEVEL:-${GPUDIRECT_LEVEL}}"
      export NCCL_P2P_LEVEL="\${NCCL_P2P_LEVEL:-${NVLINK_LEVEL}}"
      export NCCL_IB_TIMEOUT="\${NCCL_IB_TIMEOUT:-22}"
      export NCCL_IB_RETRY_CNT="\${NCCL_IB_RETRY_CNT:-7}"
      EOF
      elif [[ "$TRANSPORT" == "rdma" ]] && [[ -z "$IB_DEVICES" ]]; then
          cat >> "$OUTPUT_FILE" <<'INNER_EOF'
      # RDMA detected but no IB devices found - using TCP fallback
      export NCCL_IB_DISABLE="${NCCL_IB_DISABLE:-1}"
      INNER_EOF
          cat >> "$OUTPUT_FILE" <<EOF
      export NCCL_SOCKET_IFNAME="\${NCCL_SOCKET_IFNAME:-${RDMA_IFACES}}"
      export NCCL_P2P_LEVEL="\${NCCL_P2P_LEVEL:-${NVLINK_LEVEL}}"
      EOF
      else
          cat >> "$OUTPUT_FILE" <<'INNER_EOF'
      # TCP/Ethernet configuration (supports user overrides)
      export NCCL_IB_DISABLE="${NCCL_IB_DISABLE:-1}"
      INNER_EOF
          cat >> "$OUTPUT_FILE" <<EOF
      export NCCL_SOCKET_IFNAME="\${NCCL_SOCKET_IFNAME:-${RDMA_IFACES}}"
      export NCCL_P2P_LEVEL="\${NCCL_P2P_LEVEL:-${NVLINK_LEVEL}}"
      EOF
      fi

      cat >> "$OUTPUT_FILE" <<EOF

      # Performance Tuning
      export OMP_NUM_THREADS="\${OMP_NUM_THREADS:-${OMP_THREADS}}"

      # Multi-GPU Configuration
      export GPUS_PER_NODE="\${GPUS_PER_NODE:-${GPU_COUNT}}"
      EOF

      log "Configuration written to $OUTPUT_FILE"
      log "Auto-detection complete!"
      AUTODETECT_EOF

      RUN chmod +x /usr/local/bin/autodetect-nccl.sh

      # Set base NCCL environment variables (will be augmented by autodetect)
      ENV NCCL_DEBUG=INFO

      # Install Python packages
      # Note: PyTorch is already installed in base image
      RUN pip install --no-cache-dir \
          torchtitan \
          transformers \
          tokenizers \
          datasets \
          accelerate \
          safetensors \
          hydra-core \
          omegaconf \
          pyyaml \
          einops \
          tqdm \
          rich \
          tensorboard \
          fsspec \
          wandb

      # Set working directory
      WORKDIR /workspace

      # Default command
      CMD ["/bin/bash"]

  strategy:
    type: Docker
    dockerStrategy:
      noCache: false

  triggers:
  - type: ConfigChange
